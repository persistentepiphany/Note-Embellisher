"""
PDF Compiler Service
Compiles LaTeX documents to PDF using multiple methods
"""
import os
import subprocess
import tempfile
import shutil
from typing import Optional, Tuple
import requests
from pathlib import Path

class PDFCompiler:
    def __init__(self):
        base_dir = Path(__file__).resolve().parent.parent  # backend/
        self.output_dir = base_dir / "generated_pdfs"
        self.output_dir.mkdir(exist_ok=True)
        
        # Check if pdflatex is available
        self.has_pdflatex = self._check_pdflatex()
        
        if self.has_pdflatex:
            print("pdflatex found - local compilation available")
        else:
            print("pdflatex not found - will use cloud compilation")
    
    def _check_pdflatex(self) -> bool:
        """Check if pdflatex is installed"""
        try:
            result = subprocess.run(
                ['pdflatex', '--version'],
                capture_output=True,
                timeout=5
            )
            return result.returncode == 0
        except (subprocess.TimeoutExpired, FileNotFoundError):
            return False
    
    def compile_to_pdf(
        self, 
        latex_content: str, 
        output_filename: str,
        save_tex: bool = False
    ) -> Tuple[Optional[str], Optional[str], Optional[str]]:
        """
        Compile LaTeX content to PDF.
        
        Args:
            latex_content: Complete LaTeX document as string
            output_filename: Desired filename (without extension)
            save_tex: Whether to also save the .tex file
            
        Returns:
            Tuple of (pdf_path, tex_path, error_message)
            - pdf_path: Path to generated PDF file (None if failed)
            - tex_path: Path to saved .tex file (None if not saved)
            - error_message: Error message if compilation failed (None if success)
        """
        
        # Try local compilation first if available
        if self.has_pdflatex:
            result = self._compile_local(latex_content, output_filename, save_tex)
            if result[0]:  # If PDF was successfully generated
                return result
            print("Local compilation failed, trying cloud compilation...")
        
        # Fall back to cloud compilation
        return self._compile_cloud(latex_content, output_filename, save_tex)
    
    def _compile_local(
        self, 
        latex_content: str, 
        output_filename: str,
        save_tex: bool
    ) -> Tuple[Optional[str], Optional[str], Optional[str]]:
        """Compile LaTeX locally using pdflatex"""
        
        with tempfile.TemporaryDirectory() as tmpdir:
            # Write .tex file
            tex_path = os.path.join(tmpdir, "document.tex")
            try:
                with open(tex_path, 'w', encoding='utf-8') as f:
                    f.write(latex_content)
            except Exception as e:
                return None, None, f"Failed to write .tex file: {e}"
            
            try:
                # Run pdflatex twice for references and table of contents
                for i in range(2):
                    result = subprocess.run(
                        ['pdflatex', '-interaction=nonstopmode', 'document.tex'],
                        cwd=tmpdir,
                        capture_output=True,
                        timeout=60,
                        text=True
                    )
                    
                    if i == 1 and result.returncode != 0:  # Only check on final run
                        error_log = result.stdout + "\n" + result.stderr
                        print(f"pdflatex compilation error (return code {result.returncode})")
                        print(f"Last 500 chars of log: {error_log[-500:]}")
                        return None, None, f"pdflatex compilation failed: {error_log[-500:]}"
                
                pdf_temp_path = os.path.join(tmpdir, "document.pdf")
                
                if not os.path.exists(pdf_temp_path):
                    return None, None, "PDF file was not generated by pdflatex"
                
                # Copy PDF to output directory
                pdf_output_path = self.output_dir / f"{output_filename}.pdf"
                shutil.copy(pdf_temp_path, pdf_output_path)
                
                # Optionally save .tex file
                tex_output_path = None
                if save_tex:
                    tex_output_path = self.output_dir / f"{output_filename}.tex"
                    with open(tex_output_path, 'w', encoding='utf-8') as f:
                        f.write(latex_content)
                
                print(f"PDF compiled locally: {pdf_output_path}")
                return str(pdf_output_path), str(tex_output_path) if save_tex else None, None
                
            except subprocess.TimeoutExpired:
                return None, None, "LaTeX compilation timed out (exceeded 60 seconds)"
            except Exception as e:
                return None, None, f"Compilation error: {str(e)}"
    
    def _compile_cloud(
        self, 
        latex_content: str, 
        output_filename: str,
        save_tex: bool
    ) -> Tuple[Optional[str], Optional[str], Optional[str]]:
        """Compile LaTeX using texlive.net multipart API"""

        try:
            prepared = self._prepare_latex_for_cloud(latex_content)
            files = {
                'filecontents[]': ('document.tex', prepared, 'text/plain')
            }
            data = {
                'filename[]': 'document.tex',
                'engine': 'pdflatex',
                'return': 'pdf'
            }

            print("Sending LaTeX to texlive.net cloud compiler...")
            response = requests.post(
                'https://texlive.net/cgi-bin/latexcgi',
                files=files,
                data=data,
                timeout=120
            )

            content_type = response.headers.get('Content-Type', '').lower()
            print(f"Cloud response: status={response.status_code}, content-type={content_type}, length={len(response.content)} bytes")
            
            if response.status_code == 200 and content_type.startswith('application/pdf'):
                pdf_output_path = self.output_dir / f"{output_filename}.pdf"
                with open(pdf_output_path, 'wb') as f:
                    f.write(response.content)

                tex_output_path = None
                if save_tex:
                    tex_output_path = self.output_dir / f"{output_filename}.tex"
                    with open(tex_output_path, 'w', encoding='utf-8') as f:
                        f.write(latex_content)

                print(f"PDF compiled via cloud: {pdf_output_path}")
                return str(pdf_output_path), str(tex_output_path) if save_tex else None, None

            # Check if response is LaTeX compilation log (text/plain)
            if content_type.startswith('text/plain') or content_type.startswith('text/html'):
                error_preview = response.text[:1000] if response.text else ''
                print(f"Cloud compiler returned log/error instead of PDF: {error_preview}")
                # Look for actual LaTeX errors in the log
                if "! " in error_preview:
                    # Extract actual error
                    error_lines = [line for line in error_preview.split('\n') if line.startswith('!')]
                    actual_error = '\n'.join(error_lines[:5]) if error_lines else error_preview[:500]
                    return None, None, f"LaTeX compilation error: {actual_error}"
            
            error_preview = response.text[:500] if response.text else ''
            error_msg = (
                f"Cloud compilation failed - expected PDF but got {content_type}: {error_preview}"
            )
            return None, None, error_msg

        except requests.Timeout:
            return None, None, "Cloud compilation timed out (exceeded 120 seconds)"
        except Exception as e:
            return None, None, f"Cloud compilation error: {str(e)}"

    @staticmethod
    def _prepare_latex_for_cloud(latex_content: str) -> bytes:
        """texlive.net expects CRLF line endings in uploaded files."""
        normalized = latex_content.replace('\r\n', '\n').replace('\r', '\n')
        crlf_content = normalized.replace('\n', '\r\n')
        return crlf_content.encode('utf-8')
    
    def get_pdf_url(self, pdf_path: str) -> str:
        """
        Convert local PDF path to URL for serving to frontend.
        In production, this should be replaced with cloud storage URL.
        """
        # For now, return relative path
        # In production, upload to Firebase Storage or similar
        return f"/generated_pdfs/{Path(pdf_path).name}"


# Create singleton instance
pdf_compiler = PDFCompiler()
